/*
Copyright 2020,2021 Avi Zimmerman

This file is part of kvdi.

kvdi is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

kvdi is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with kvdi.  If not, see <https://www.gnu.org/licenses/>.
*/

package types

import (
	"errors"
	"fmt"
	"net/http"
	"regexp"
	"strings"

	metav1 "github.com/tinyzimmer/kvdi/apis/meta/v1"
	rbacv1 "github.com/tinyzimmer/kvdi/apis/rbac/v1"
)

// API Request/Response types

// LoginRequest represents a request for a session token. Different auth providers
// may not always need this request, and can instead redirect /api/login as needed.
// All the auth provider needs to do in the end is return a JWT token that contains
// a fulfilled VDIUser.
// +k8s:deepcopy-gen=false
type LoginRequest struct {
	// Username
	Username string `json:"username"`
	// Password
	Password string `json:"password"`
	// State generated by requesting client to prevent CSRF and retrieve tokens
	// from an oidc flow
	State string `json:"state"`
	// the underlying request object for usage by auth providers
	request *http.Request
}

// GetUsername returns the username in the request. Providers should use
// this and the other getters instead.
func (l *LoginRequest) GetUsername() string { return l.Username }

// GetPassword returns the password in the request.
func (l *LoginRequest) GetPassword() string { return l.Password }

// GetState returns the state secret in the request.
func (l *LoginRequest) GetState() string { return l.State }

// SetRequest sets the request object in the LoginRequest.
func (l *LoginRequest) SetRequest(r *http.Request) {
	l.request = r
}

// GetRequest returns the request object in the LoginRequest.
func (l *LoginRequest) GetRequest() *http.Request {
	return l.request
}

// AuthorizeRequest is a request with an OTP for receiving an authorized token.
type AuthorizeRequest struct {
	// The one-time password
	OTP string `json:"otp"`
	// The state secret for the request flow
	State string `json:"state"`
}

// GetOTP returns the OTP from the request.
func (a *AuthorizeRequest) GetOTP() string { return a.OTP }

// GetState returns the state from the request.
func (a *AuthorizeRequest) GetState() string { return a.State }

// SessionResponse represents a response with a new session token
type SessionResponse struct {
	// The X-Session-Token to use for future requests.
	Token string `json:"token"`
	// The time the token expires.
	ExpiresAt int64 `json:"expiresAt"`
	// Whether an HttpOnly was sent back with the request enabling token refresh.
	Renewable bool `json:"renewable"`
	// Information about the authenticated user and their permissions.
	User *VDIUser `json:"user"`
	// Whether the user is fully authorized (e.g. false if MFA is required but not provided yet)
	Authorized bool `json:"authorized"`
	// The state secret generated by the client
	State string `json:"state"`
}

// CreateUserRequest represents a request to create a new user. Not all auth
// providers will be able to implement this route and can instead return an
// error describing why.
type CreateUserRequest struct {
	// The user name for the new user.
	Username string `json:"username"`
	// The password for the new user.
	Password string `json:"password"`
	// Roles to assign the new user. These are the names of VDIRoles in the cluster.
	Roles []string `json:"roles"`
}

// Validate validates a new user request
func (r *CreateUserRequest) Validate() error {
	if r.Username == "" || r.Password == "" {
		return errors.New("'username' and 'password' must be provided in the request")
	}
	if r.Roles == nil || len(r.Roles) == 0 {
		return errors.New("You must assign at least one role to the user")
	}
	if strings.Contains(r.Username, ":") {
		return errors.New("Username cannot contain the ':' character")
	}
	return nil
}

// UpdateUserRequest requests updates to an existing user. Not all auth
// providers will be able to implement this route and can instead return an
// error describing why.
type UpdateUserRequest struct {
	// When populated, will change the password for the user.
	Password string `json:"password"`
	// When populated will change the roles for the user.
	Roles []string `json:"roles"`
}

// Validate the UpdateUserRequest
func (r *UpdateUserRequest) Validate() error {
	if r.Password == "" && len(r.Roles) == 0 {
		return errors.New("You must specify either a new password or a list of roles")
	}
	return nil
}

// UpdateMFARequest sets the MFA configuration for the user. If enabling,
// a provisioning URI will be returned.
type UpdateMFARequest struct {
	// When set, will enable MFA for the given user. If false, will disable MFA.
	Enabled bool `json:"enabled"`
}

// MFAResponse contains the response to an UpdateMFARequest or GetMFARequest.
type MFAResponse struct {
	// Whether MFA is enabled for the user
	Enabled bool `json:"enabled"`
	// If enabled is set, a provisioning URI is also returned.
	ProvisioningURI string `json:"provisioningURI"`
	// If enabled is set, whether or not the user has verified their MFA setup
	Verified bool `json:"verified"`
}

// CreateRoleRequest represents a request for a new role.
type CreateRoleRequest struct {
	// The name of the new role
	Name string `json:"name"`
	// Annotations to apply to the role
	Annotations map[string]string `json:"annotations"`
	// Rules to apply to the new role.
	Rules []rbacv1.Rule `json:"rules"`
}

// GetName returns the name of the new role
func (r *CreateRoleRequest) GetName() string { return r.Name }

// GetAnnotations returns the annotations provided in the request
func (r *CreateRoleRequest) GetAnnotations() map[string]string { return r.Annotations }

// Validate the CreateRoleRequest
func (r *CreateRoleRequest) Validate() error {
	if r.Name == "" {
		return errors.New("A name is required for the new role")
	}
	for _, rule := range r.Rules {
		if err := validatePatterns(rule.ResourcePatterns); err != nil {
			return err
		}
	}
	return nil
}

// GetRules returns the rules for a new role request, or a single-element slice with
// a deny-all rule if none are provided.
func (r *CreateRoleRequest) GetRules() []rbacv1.Rule {
	if r.Rules == nil {
		return []rbacv1.Rule{{
			Verbs:            []rbacv1.Verb{},
			Resources:        []rbacv1.Resource{},
			ResourcePatterns: []string{},
			Namespaces:       []string{},
		}}
	}
	return r.Rules
}

// UpdateRoleRequest requests updates to an existing role. The existing attributes
// will be entirely replaced with those supplied in the payload.
type UpdateRoleRequest struct {
	// The new annotations for the role
	Annotations map[string]string `json:"annotations"`
	// The new rules for the role.
	Rules []rbacv1.Rule `json:"rules"`
}

// GetAnnotations returns the annotations provided in the request
func (r *UpdateRoleRequest) GetAnnotations() map[string]string { return r.Annotations }

// GetRules returns the rules for an update role request, or a single-element slice with
// a deny-all rule if none are provided.
func (r *UpdateRoleRequest) GetRules() []rbacv1.Rule {
	if r.Rules == nil {
		return []rbacv1.Rule{{
			Verbs:            []rbacv1.Verb{},
			Resources:        []rbacv1.Resource{},
			ResourcePatterns: []string{},
			Namespaces:       []string{},
		}}
	}
	return r.Rules
}

// Validate the UpdateRoleRequest
func (r *UpdateRoleRequest) Validate() error {
	for _, rule := range r.Rules {
		if err := validatePatterns(rule.ResourcePatterns); err != nil {
			return err
		}
	}
	return nil
}

// validatePatterns takes a list of regexes and returns an error if any of them
// are invalid.
func validatePatterns(patterns []string) error {
	for _, pattern := range patterns {
		if _, err := regexp.Compile(pattern); err != nil {
			return fmt.Errorf("%s is an invalid regex: %s", pattern, err.Error())
		}
	}
	return nil
}

// CreateSessionRequest requests a new desktop session with the givin parameters.
type CreateSessionRequest struct {
	// The template to create the session from.
	Template string `json:"template"`
	// The namespace to launch the template in. Defaults to default.
	Namespace string `json:"namespace,omitempty"`
	// A service account to tie to the desktop session. Defaults to none.
	ServiceAccount string `json:"serviceAccount,omitempty"`
}

// Validate the CreateSessionRequest
func (r *CreateSessionRequest) Validate() error {
	if r.Template == "" {
		return errors.New("A template is required")
	}
	return nil
}

// GetTemplate returns the template for this request
func (r *CreateSessionRequest) GetTemplate() string { return r.Template }

// GetNamespace returns the namspace for this request, or the default namespace
// if not provided.
func (r *CreateSessionRequest) GetNamespace() string {
	if r.Namespace != "" {
		return r.Namespace
	}
	return metav1.DefaultNamespace
}

// GetServiceAccount returns the service account for this request.
func (r *CreateSessionRequest) GetServiceAccount() string { return r.ServiceAccount }

// CreateSessionResponse returns the name of the Desktop and what namespace
// it is running in.
type CreateSessionResponse struct {
	Name      string `json:"name"`
	Namespace string `json:"namespace"`
}

// DesktopSessionsResponse contains a list of desktop sessions and information
// about their statuses.
type DesktopSessionsResponse struct {
	// A list of desktop sessions.
	Sessions []*DesktopSession `json:"sessions"`
}

// DesktopSession describes the properties and status of a desktop session.
type DesktopSession struct {
	// The name of the desktop session.
	Name string `json:"name"`
	// The namespace of the desktop session.
	Namespace string `json:"namespace"`
	// The username of the user who owns this session.
	User string `json:"user"`
	// The service account being used by this session.
	ServiceAccount string `json:"serviceAccount"`
	// The template this session is booted from.
	Template string `json:"template"`
	// Connection status for the session.
	Status *DesktopSessionStatus `json:"status"`
}

// NamespacedName returns the namespaced-name representation of this session.
func (d *DesktopSession) NamespacedName() string { return fmt.Sprintf("%s/%s", d.Namespace, d.Name) }

// DesktopSessionStatus contains information about the connection status for a session's
// display and audio.
type DesktopSessionStatus struct {
	// Connection status for the desktop's display.
	Display *ConnectionStatus `json:"display"`
	// Connection status for the desktop's audio.
	Audio *ConnectionStatus `json:"audio"`
}

// ConnectionStatus describes the connection status of a desktop's display or audio.
type ConnectionStatus struct {
	// Whether or not a client is connected to the stream.
	Connected bool `json:"connected"`
	// The address of the client connected to the stream.
	ClientAddr string `json:"clientAddr,omitempty"`
	// The app instance handling the proxy for this stream.
	ProxyPod string `json:"proxyPod,omitempty"`
}

// StatDesktopFileResponse contains the info for a queried file inside a desktop
// dession.
type StatDesktopFileResponse struct {
	Stat *FileStat `json:"stat"`
}

// FileStat contains information about a queried file. Contents will only contain
// nested FileStat objects when this object represents the root of the query.
type FileStat struct {
	// The name of the file or directory
	Name string `json:"name"`
	// True if the file is a directory
	IsDirectory bool `json:"isDirectory"`
	// The size of the file when IsDirectory is false
	Size int64 `json:"size"`
	// When IsDirectory is true, the contents of the directory
	Contents []*FileStat `json:"contents,omitempty"`
}
